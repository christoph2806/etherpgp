/*!
 * Start Bootstrap - Freelancer v5.0.0 (https://startbootstrap.com/template-overviews/freelancer)
 * Copyright 2013-2018 Start Bootstrap
 * Licensed under MIT (https://github.com/BlackrockDigital/startbootstrap-freelancer/blob/master/LICENSE)
 */

const ethers=require("ethers"),pgpABI=require("./pgpABI.json"),openpgp=require("openpgp"),IPFS_URL="https://ipfs.infura.io:5001",ipfs=require("nano-ipfs-store").at(IPFS_URL);etherpgp=new function(){this.ipfs=ipfs,this.init_metaMask=async function(){let e=this;void 0===window.ethereum?(alert("Looks like you need a Dapp browser to get started."),alert("Consider installing MetaMask!")):ethereum.enable().catch(function(e){"User rejected provider access"===e||alert("There was an issue signing you in.")}).then(function(t){"1"!==ethereum.networkVersion&&alert("This application requires the main network, please switch it in your MetaMask UI."),e.account=t[0]})},this.init_ethers=function(){this.ethers=ethers,this.provider=new ethers.providers.Web3Provider(web3.currentProvider),this.signer=this.provider.getSigner()},this.init_pgp=function(){this.pgpContract="1"===ethereum.networkVersion?new ethers.Contract("0xa6a52efd0e0387756bc0ef10a34dd723ac408a30",pgpABI,this.provider):new ethers.Contract("0x9d7efd45e45c575cafb25d49d43556f43ebe3456",pgpABI,this.provider),this.pgpKeys={}},this.getPGPKey=async function(e){if(console.log("Address: ",e),this.pgpKeys[e])return this.pgpKeys[e];{const t=await this.pgpContract.addressToPublicKey(e);return!!t&&(console.log(t),this.pgpKeys[e]=JSON.parse(await ipfs.cat(t)),this.pgpKeys[e])}},this.registerPGPKey=async function(){const e=this.account;if(await this.getPGPKey(e))throw"Key already set on PGP contract, should only be set once";this.signedSeed=await this.signer.signMessage(`I hereby confirm that I am owner of ${e}`);const{privateKeyArmored:t,publicKeyArmored:s}=await openpgp.generateKey({userIds:[{address:e}],curve:"p256",passphrase:this.signedSeed}),i={privateKeyArmored:t,publicKeyArmored:s};this.pgpKeys[e]=i;const r=await ipfs.add(JSON.stringify(i));return this.pgpContract.connect(this.signer).addPublicKey(r,{value:0,gasLimit:16e4,gasPrice:ethers.utils.parseUnits("40","Gwei")})},this.decryptMessage=async function(e,t){const s=await this.getPGPKey(t);if(!s)throw"PGP Key not set for this address";const{keys:i}=await openpgp.key.readArmored(s.privateKeyArmored);this.signedSeed=await this.signer.signMessage(`I hereby confirm that I am owner of ${t}`);const r=i[0];return await r.decrypt(this.signedSeed),decrypted=await openpgp.decrypt({message:await openpgp.message.readArmored(e),privateKeys:[r]}),decrypted.data},this.encryptMessage=async function(e,t){const s=await this.getPGPKey(t);if(!s)throw"PGP Key not set for this address";return openpgp.encrypt({message:openpgp.message.fromText(e),publicKeys:(await openpgp.key.readArmored(s.publicKeyArmored)).keys}).then(e=>e.data).catch(function(e){console.log(e)})},this.init_ethers(),this.init_pgp(),this.init_metaMask()},module.exports=etherpgp;